def match_template(image, model, confidence_threshold=0.6 ,output_dir="test"):
    """
    识别目标并绘制边界框，同时保存未经标注的原始图片。

    参数:
        image (numpy.ndarray | PIL.Image.Image): 输入图像，可以是 numpy 格式或 PIL.Image 格式。
        model: 目标检测模型，需支持返回 `results.boxes`。
        confidence_threshold (float): 置信度阈值。
        output_dir (str): 输出文件夹路径。

    返回:
        detections (list): 检测到的目标信息列表。
    """
    results = model(image)

    # 确保图像是 PIL.Image 格式
    if isinstance(image, np.ndarray):
        original_image = Image.fromarray(image)  # 保存原始图像
    else:
        original_image = image.copy()  # 保存原始图像

    image = original_image.copy()  # 用于绘制标注的图像

    # 如果结果是列表，取第一个
    if isinstance(results, list):
        results = results[0]

    detections = []

    if hasattr(results, "boxes"):
        boxes = results.boxes
        for box in boxes:
            cls_id = int(box.cls)  # 类别 ID
            confidence = box.conf  # 置信度
            coords = box.xyxy.tolist()[0]  # 边界框坐标
            x1, y1, x2, y2 = map(int, coords)

            # 如果置信度满足阈值要求，记录检测结果
            if confidence >= confidence_threshold:
                detections.append({
                    "class_id": cls_id,
                    "confidence": confidence,
                    "box": (x1, y1, x2, y2)
                })

        # 绘制所有检测框
        draw = ImageDraw.Draw(image)
        try:
            font = ImageFont.load_default()
        except IOError:
            font = None

        for detection in detections:
            x1, y1, x2, y2 = detection["box"]
            cls_id = detection["class_id"]

            # 绘制边界框
            draw.rectangle([x1, y1, x2, y2], outline="red", width=3)

            # 绘制类别 ID
            text = f"ID: {cls_id}"
            if font:
                text_bbox = font.getbbox(text)  # 使用 getbbox 获取文本边界框
                text_size = (text_bbox[2] - text_bbox[0], text_bbox[3] - text_bbox[1])  # 宽度和高度
            else:
                text_bbox = draw.textbbox((0, 0), text)  # 如果没有字体，用 draw.textbbox
                text_size = (text_bbox[2] - text_bbox[0], text_bbox[3] - text_bbox[1])

                # 确定文本位置
                text_position = (x1, y1 - text_size[1] if y1 > text_size[1] else y1 + 2)
                draw.text(text_position, text, fill="red", font=font)
    else:
        print("未检测到有效的边界框")

    # 确保输出目录存在
    os.makedirs(output_dir, exist_ok=True)

    # 保存原始图片到 original 文件夹
    original_dir = os.path.join(output_dir, "original")
    os.makedirs(original_dir, exist_ok=True)
    original_path = os.path.join(original_dir, f"original_image_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}.jpg")
    original_image.save(original_path)

    # 保存标注后的图片
    annotated_path = os.path.join(output_dir, f"annotated_image_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}.jpg")
    image.save(annotated_path)

    return detections